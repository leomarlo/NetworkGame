<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" href="stylesheet.css">
</head>
<body onload="startGame()">
<div class="header">
  <h1> Testing Ground for Network Games</h1>
</div>
<div class="panel" id="leftpanel">
 <h3 id="Ply_1_name"> Player I </h3>
  <p> Pebbles </p>
 <canvas class="sidecanvas" id="leftpebblescanvas"></canvas>
 <p> Arrows </p>
 <canvas class="sidecanvas" id="leftarrowcanvas"></canvas>
</div>
<div class="canvascontainer" id="container">
  <canvas id="GameField"></canvas>
</div>
<div class="actionpanel">
  <button id="finished1">Player 1 to start</button>
  <button id="finished2">Player 2 to start</button>
</div>
<div class="gamepanel">
  <button id="Reset" style="background-color: #ccc;">Reset</button>
  <button id="Rules" style="background-color: #ccc;">How To Play</button>
</div>
<div class="panel" id="rightpanel">
  <h3 id="Ply_2_name"> Player II </h3>
  <p> Pebbles </p>
    <canvas class="sidecanvas" id="rightpebblescanvas"></canvas>
 <p> Arrows </p>
    <canvas class="sidecanvas" id="rightarrowcanvas"></canvas>
</div>
</body>
<script >

var mainfieldsizes=[300,300];
var panelfieldsizes=[100,190];
var per_turn_moves={
  max_arrow:1,
  max_pebble:1,
  max_pebble_and_arrow:1}

function color_choice(player_number,opaque) {
  if (player_number==1){
    if (opaque){ return 'rgba(255,127,80,0.5)'; }
    else { return 'rgba(255,127,80,1.0)';  }  }
  else {
    if (opaque){ return "rgba(115,144,153,0.5)"; }
    else { return "rgba(115,144,153,1.0)"; }  }
}

function GameRules() {
  this.constrain_placements_per_turn=true;
  this.place_arrow_only_on_pebbles=true;
  this.per_turn_moves=per_turn_moves;
  this.place_pebbles_atop=false;
  this.place_arrows_atop=false;
  this.constrain_arrow_dist_to=4;
  this.allow_self_arrow=false;
}

function Euclidean(x,y){return Math.sqrt(Math.pow(x[0]-y[0],2)+Math.pow(x[1]-y[1],2))}

/*function LpDist(x,y,p){
    var alert_flag=false;
    var Lenx=x.length;
    var Leny=y.length;
    if (Lenx!=Leny){
      if (alert_flag){alert('vectors not the same length')}
      Len=Math.min(Lenx,Leny);
    }
    else {
      Len=Lenx;
    }
    var temp=0;
    var index;
    for (index=0; index<Len; index++){
      temp+=Math.abs(Math.pow((x[0]-y[0]),p));
    }
   return Math.pow(temp,1/p);
}*/

function startGame() {
    // add eventlisteners for the reset and rules buttons
    Reset.addEventListener('click', ()=>{reset()});
    Rules.addEventListener('click', ()=>{alert(Rules_text)});
    // make the border colours of the panels conform to the players color;
    document.getElementById("leftpanel").style.borderColor=color_choice(1,false);
    document.getElementById("rightpanel").style.borderColor=color_choice(2,false);
    // make the buttons colours of the respective players conform to the colour pallette
    Ply_2_fin.style.background=color_choice(2,false);
    Ply_1_fin.style.background=color_choice(1,false);

    // initialize the main game area;
    var maincanvas=document.getElementById("GameField");
    maincanvas.width=mainfieldsizes[0];
    maincanvas.height=mainfieldsizes[1];
    window.MainArea = new GameArea(maincanvas,10,true);
    MainArea.setgridparameters(8,8,2,"#000");
    MainArea.updategrid();

    // define the GameRules
    ThisGame = new GameRules();

    // define the two players, both of "class" Player
    // players own the pebbles and arrows as methods and properties.
    Player1= new Player(1,23,7);
    Player2= new Player(2,23,7);
    Players=[Player1,Player2];
    // initialize them.
    Player1.initialize();
    Player2.initialize();

    // add event listeners to the resepective player buttons.
    Ply_2_fin.addEventListener('click', Player_2_starts);
    Ply_1_fin.addEventListener('click', Player_1_starts);

}


function Player_1_starts () {

  // make the other button color faint.
  Ply_2_fin.style.background=color_choice(2,true);
  Ply_1_fin.style.background=color_choice(1,false);
  // change the innerHTML to I finished my turn.
  var finished_sentence='I\'m done';
  Ply_2_fin.innerHTML=finished_sentence;
  Ply_1_fin.innerHTML=finished_sentence;
  // remove eventlistener and add the new ones.
  Ply_2_fin.removeEventListener('click', Player_2_starts);
  Ply_1_fin.removeEventListener('click', Player_1_starts);
  //add event listeners
  add_finished_button_listeners();
  // let the games begin
  Player1.myturn()

}

function Player_2_starts () {
  // make the other button color faint.
  Ply_1_fin.style.background=color_choice(1,true);
  Ply_2_fin.style.background=color_choice(2,false);
  // change the innerHTML to I finished my turn.
  var finished_sentence='I\'m done';
  Ply_1_fin.innerHTML=finished_sentence;
  Ply_2_fin.innerHTML=finished_sentence;
  // remove eventlistener and add the new ones.
  Ply_1_fin.removeEventListener('click', Player_1_starts);
  Ply_2_fin.removeEventListener('click', Player_2_starts);
  //add event listeners
  add_finished_button_listeners();
  // let the games begin
  Player2.myturn()
}

function remove_finished_button_listeners (){
  //add_finished_button_listeners();
  Ply_2_fin.removeEventListener('click',Player1.myturn);
  Ply_2_fin.removeEventListener('click',Player2.removelisteners);
  Ply_2_fin.removeEventListener('click',Player2.undoselection);
  Ply_1_fin.removeEventListener('click',Player2.myturn);
  Ply_1_fin.removeEventListener('click',Player1.removelisteners);
  Ply_1_fin.removeEventListener('click',Player1.undoselection);
}
function add_finished_button_listeners (){
  //add_finished_button_listeners();
  Ply_2_fin.addEventListener('click',Player1.myturn);
  Ply_2_fin.addEventListener('click',Player2.removelisteners);
  Ply_2_fin.addEventListener('click',Player2.undoselection);
  Ply_1_fin.addEventListener('click',Player2.myturn);
  Ply_1_fin.addEventListener('click',Player1.removelisteners);
  Ply_1_fin.addEventListener('click',Player1.undoselection);
}

var Rules_text =
"Start) Press \"Player 1 to start\" or \"Player 1 to start\"\n\n"+
"Selection) If it is the turn of player X (1 or 2), the that player may click on any of "+
"the pebbles or arrows in her or his stock. Once a selection is made the pebble or arrow can be placed in the main field.\n\n"+
"Placement of pebble) A pebble is placed by clicking simply on the game area, close to one of the grid points where it ought to be placed."+
"Once the pebble is placed it appears on the game area and disappears from the stock.\n\n"+
"Placement of arrow) An arrow is placed by clicking on the starting grid point, or close by, and then after that on the finishing grid point."+
"The starting and finishing point may not be the same one. In other words self-edges are not allowed. "+
"Once the arrow is placed it appears on the game area and disappears from the stock.\n\n"+
"Reset) Pressing the Reset-button will clear all the placed pebbles and arrows from the field and replenish the respective stocks.";

function reset(){
  MainArea.clear(true);
  MainArea.pebble_placements=new Array();
  MainArea.arrow_placements=new Array();
  MainArea.arrow_nr=0; // how many arrows there are currently on the board
  MainArea.pebbles_nr=0;
  Ply_2_fin.style.background=color_choice(2,false);
  Ply_1_fin.style.background=color_choice(1,false);
  remove_finished_button_listeners();
  Ply_2_fin.innerHTML="Player 2 to start";
  Ply_1_fin.innerHTML="Player 1 to start";
  // reset all the pebbles and arrows or player one and two
  Player1.initialize();
  Player2.initialize();

  marea_cnv.removeEventListener('click', Player1.place_arrow );
  marea_cnv.removeEventListener('click', Player1.place_pebble );
  marea_cnv.removeEventListener('click', Player2.place_arrow );
  marea_cnv.removeEventListener('click', Player2.place_pebble );
  l_arr_cnv.removeEventListener('click', Player1.select_arrow );
  l_peb_cnv.removeEventListener('click', Player1.select_pebble);
  r_arr_cnv.removeEventListener('click', Player2.select_arrow );
  r_peb_cnv.removeEventListener('click', Player2.select_pebble);
  /*Ply_1_fin.selected_pbble=null;
  Ply_1_fin.found_pebble_position=false;
  Ply_1_fin.pebble_position=[null,null];
  Ply_1_fin.selected_arrow=null;
  Ply_1_fin.arrow_starting_point=[null,null];
  Ply_1_fin.arrow_ending_point=[null,null];
  Ply_1_fin.found_arrow_starting=false;
  Ply_1_fin.found_arrow_ending=false;

  Ply_2_fin.selected_pbble=null;
  Ply_2_fin.found_pebble_position=false;
  Ply_2_fin.pebble_position=[null,null];
  Ply_2_fin.selected_arrow=null;
  Ply_2_fin.arrow_starting_point=[null,null];
  Ply_2_fin.arrow_ending_point=[null,null];
  Ply_2_fin.found_arrow_starting=false;
  Ply_2_fin.found_arrow_ending=false;*/

  // add eventlistener for whom to start.
  Ply_2_fin.addEventListener('click', Player_2_starts);
  Ply_1_fin.addEventListener('click', Player_1_starts);
}


function GameArea (canvas,padding,mainarea){
  this.mainarea=mainarea;
  this.canvas=canvas;
  this.padding=padding;
  this.arrow_nr=0; // how many arrows there are currently on the board
  this.pebbles_nr=0; //how many pebbles there are currently on the board.
  // add this arrow to the infield stock and show it there
  this.pebble_placements=new Array();
  this.arrow_placements=new Array();
  this.width=this.canvas.width;
  this.height=this.canvas.height;
  this.context = this.canvas.getContext("2d");
  this.withgrid=false; // is there a grid or not;
  this.clear = function(withgrid) {  // should become this.widthgrid.
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (withgrid){this.updategrid();}
    };
  this.setgridparameters = function(xpts,ypts,size,color) {
      this.xpts=xpts; // creates these properties of GameArea
      this.ypts=ypts;
      this.size=size;
      this.gridcolor=color;
      // defining the distance between 2 consecutive gridlines
      if (this.mainarea){
        this.grid_dy=(this.height-2*this.padding)/(this.ypts-1); // distance between two gridlines
      } else {
        this.grid_dy=this.height/(this.ypts);;
      };
      this.grid_dx=(this.width-2*this.padding)/(this.xpts-1);
    }
  this.updategrid = function(){
      this.context.fillStyle = "red";
      this.withgrid=true;
      var ix,iy;
      for (iy=0; iy < this.ypts; iy++) {
        if (this.mainarea){
          var y= this.padding+iy*this.grid_dy;
        } else {
          var y=(iy+1/2)*this.grid_dy;
        }
        this.context.beginPath();
        this.context.moveTo(this.padding, y);
        this.context.lineTo(this.width-this.padding, y);
        this.context.strokeStyle = 'rgba(0,0,0,0.5)';
        this.context.lineWidth=1;
        this.context.stroke();
      };
      for (ix = 0; ix < this.xpts; ix++) {
        let x= this.padding+ix*this.grid_dx;
        this.context.beginPath();
        this.context.moveTo(x, this.padding);
        this.context.lineTo(x, this.height-this.padding);
        this.context.strokeStyle = 'rgba(0,0,0,0.5)';
        this.context.lineWidth=1;
        this.context.stroke();
        for (iy=0; iy < this.ypts; iy++) {
          if (this.mainarea){
            var y= this.padding+iy*this.grid_dy;
          } else {
            var y=(iy+1/2)*this.grid_dy;
          }
          this.context.fillStyle = this.gridcolor;
          this.context.beginPath();
          this.context.arc(x, y, this.size, 0, 2 * Math.PI);
          this.context.fill();
        };
      };


    };
    //var placed_element= {Player_nr:this.playernumber, arrow_number:this.selected_arrow, placement_number:MainArea.arrow_nr, placement_starting_pos: this.arrow_starting_point,  placement_ending_pos: this.arrow_ending_point };

    this.are_pebbles_here = function(pos) {
      //alert("look for pebbles at this position")
      var peb_ord_in; // pebbles order index
      var placements_obj=new Array();
      // Go through all pebbles and return the object of that placement
      for (peb_ord_in=0; peb_ord_in<this.pebble_placements.length; peb_ord_in++) {
        //alert(this.pebble_placements[peb_ord_in].placement_pos[0])
        condition=this.pebble_placements[peb_ord_in].placement_pos[0]==pos[0] && this.pebble_placements[peb_ord_in].placement_pos[1]==pos[1];
        if (condition){
          placements_obj.push(this.pebble_placements[peb_ord_in]);
        }
      }
      return(placements_obj);
    }

    this.are_arrows_here= function (loc_ini, loc_fini){
      var arr_ord_in; // pebbles order index
      var placements_obj=new Array();
      // Go through all pebbles and return the object of that placement
      for (arr_ord_in=0; arr_ord_in<this.arrow_placements.length; arr_ord_in++) {
        //alert(this.pebble_placements[peb_ord_in].placement_pos[0])
        condition_fini=this.arrow_placements[arr_ord_in].placement_ending_pos[0]==loc_fini[0] &&  this.arrow_placements[arr_ord_in].placement_ending_pos[1]==loc_fini[1];
        condition_ini=this.arrow_placements[arr_ord_in].placement_starting_pos[0]==loc_ini[0] &&  this.arrow_placements[arr_ord_in].placement_starting_pos[1]==loc_ini[1];
        if (condition_ini && condition_fini){
          placements_obj.push(this.arrow_placements[arr_ord_in]);
        }
      }
      return(placements_obj);
    }

    this.refresh = function(){
      // clear everything
      this.clear(this.withgrid);
      // first all the pebbles then all the arrows in their order of placement.
      var peb_ord_in, arr_ord_in; // pebbles order index
      // probably I should first find the order of pebbles this.pebble_placements.placement_number;
      for (peb_ord_in=0; peb_ord_in<this.pebble_placements.length; peb_ord_in++) {
        var element=this.pebble_placements[peb_ord_in];
        if (this.pebble_placements[peb_ord_in].Player_nr==1){
            Player1.pebbls_infield[element.pebble_number].update();}
        else{ Player2.pebbls_infield[element.pebble_number].update();}
      }
      for (arr_ord_in=0; arr_ord_in<this.arrow_placements.length; arr_ord_in++) {
        var element=this.arrow_placements[arr_ord_in];
        if (this.arrow_placements[arr_ord_in].Player_nr==1){
            Player1.arrows_infield[element.arrow_number].update();}
        else{ Player2.arrows_infield[element.arrow_number].update();}
      }
    }
}

function highlight_pebble(pebble_id_obj,highlight){

  if (pebble_id_obj.Player==1){
    var thepebble=Player1.pebbls_infield[pebble_id_obj.pebble];
  } else {
    var thepebble=Player2.pebbls_infield[pebble_id_obj.pebble];}

  thepebble.color=color_choice(pebble_id_obj.Player,highlight);
  if (highlight){thepebble.size+=2;} else {thepebble.size-=2;}
  MainArea.refresh();
}

function Player(playernumber, pebbles, arrows) {
  var self=this; //don't ask me why, but otherwise I cannot callback methods from Player. WTF. See https://stackoverflow.com/questions/20279484/how-to-access-the-correct-this-inside-a-callback
  this.playernumber=playernumber;
  this.opponentnumber=3-playernumber;
  this.color=color_choice(playernumber,false);
  this.pebbles=pebbles; //total number of pebbles in stock initially
  this.arrows=arrows; // total number of arrows in stock initially
  this.pebbles_played_this_turn=0;
  this.arrows_played_this_turn=0;
  this.hightlighted_pebble={Player:null,pebble:null};

  this.get_player_name = function(name){
    this.player_name=name;
    document.getElementById("Ply_"+this.playernumber+"_name").innerHTML=this.player_name;
  }
  //this.score= {"pebbles":init.pebbles, "arrows":init.arrows};
  if (this.playernumber==1){
    var arrowcanvas=l_arr_cnv;//document.getElementById("leftarrowcanvas");
    var pebblescanvas=l_peb_cnv;//document.getElementById("leftpebblescanvas");
  }  else  {
    var arrowcanvas=r_arr_cnv;//document.getElementById("rightarrowcanvas");
    var pebblescanvas=r_peb_cnv;//document.getElementById("rightpebblescanvas");
  }
  arrowcanvas.width=panelfieldsizes[0];
  arrowcanvas.height=panelfieldsizes[1];
  pebblescanvas.width=panelfieldsizes[0];
  pebblescanvas.height=panelfieldsizes[1];
  this.arrowsarea = new GameArea(arrowcanvas,10,false);
  this.pebblsarea = new GameArea(pebblescanvas,10,true);

  this.arrowwidth=5;
  this.arrowsarea.setgridparameters(2,arrows,2,"black");
  this.arrowsarea.updategrid();

  this.pebblesize=5;
  this.pebblecols=4;
  this.pebblsarea.setgridparameters(this.pebblecols,(pebbles-(pebbles%this.pebblecols))/this.pebblecols+1,2,"black");
  this.pebblsarea.updategrid();
  //alert('hello');
  //alert("width is "+this.arrowsarea.width+" and height is "+this.arrowsarea.height);
  //alert("width is and height is ");

  this.initialize = function() {
    //alert(this.arrowsarea.xpts);
    var arrows_instock = new Array(this.arrows);
    var pebbls_instock = new Array(this.pebbles);
    var arrows_infield = new Array(this.arrows);
    var pebbls_infield = new Array(this.pebbles);

    var arr_in,peb_in;

    // add the arrows to the stock
    for (arr_in=0; arr_in<this.arrows; arr_in++ ){
      arrows_instock[arr_in] = new canvas_arrow(this.arrowsarea, [0,arr_in], [1,arr_in],this.color,this.arrowwidth,arr_in);
      arrows_instock[arr_in].update();
    }
    this.arrows_instock=arrows_instock;

    // add the pebbles to the stock.
    for (peb_in=0; peb_in<this.pebbles; peb_in++) {
      let x_in=peb_in%this.pebblecols;
      let y_in=(peb_in-x_in)/this.pebblecols;
      pebbls_instock[peb_in] = new canvas_pebbles(this.pebblsarea, [x_in,y_in], this.color,this.pebblesize,peb_in);
      pebbls_instock[peb_in].update();
    }
    this.pebbls_instock=pebbls_instock;

    // add the arrow and pebbles to the field (initially none)
    this.arrows_infield=arrows_infield;
    this.pebbls_infield=pebbls_infield;

    this.selected_arrow=null;
    this.selected_pbble=null;
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;
    this.arrow_starting_point=[null,null];
    this.arrow_ending_point=[null,null];
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];
    // highlight pebble on marking.
    this.hightlighted_pebble={Player:null,pebble:null};

  }

  this.update_arrow_canvas = () => {
    // clear the arrow and pebbles canvases

    this.arrowsarea.clear(true);
    // initialize looping indices
    var arr_in;
    // update the arrows to the stock
    for (arr_in=0; arr_in<this.arrows; arr_in++ ){
      if (this.arrows_instock[arr_in] != null){this.arrows_instock[arr_in].update(); }
    }
  }

  this.update_pebbles_canvas = () => {
    //alert('update pebbles canvas inside function')
    // clear the arrow and pebbles canvases
    this.pebblsarea.clear(true);
    // initialize looping indices
    var peb_in;
    // add the pebbles to the stock.
    for (peb_in=0; peb_in<this.pebbles; peb_in++) {
      if (this.pebbls_instock[peb_in] != null){this.pebbls_instock[peb_in].update(); };
    }
  }

  this.update_canvases = () => {
    // update all the canvases from the player side.
    this.update_pebbles_canvas();
    this.update_arrow_canvas();
  }

  this.removelisteners = () => {
    if (this.playernumber==1){
      l_arr_cnv.removeEventListener('click', this.select_arrow );
      l_peb_cnv.removeEventListener('click', this.select_pebble);
      //alert('event listeners for player'+this.playernumber+' canvases are removed')
    }  else  {
      r_arr_cnv.removeEventListener('click', this.select_arrow );
      r_peb_cnv.removeEventListener('click', this.select_pebble);
      //alert('event listeners for player'+this.playernumber+' canvases are removed')

    }
  }

  this.undoselection = () => {
    if (this.selected_pbble!=null){
      this.pebbls_instock[self.selected_pbble].color=this.color;
      this.pebbls_instock[self.selected_pbble].update();
    }
    if (this.selected_arrow!=null){
      // arrow hasn't been placed.
      this.arrows_instock[self.selected_arrow].color=this.color;
      this.arrows_instock[self.selected_arrow].update();
    }
    // removeEventListener of the main area
    marea_cnv.removeEventListener('click', self.place_arrow );
    // removeEventListener of the main area
    marea_cnv.removeEventListener('click', self.place_pebble );
    this.selected_pbble=null;
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];
    this.selected_arrow=null;
    this.arrow_starting_point=[null,null];
    this.arrow_ending_point=[null,null];
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;

    // reset the pebbles placed count for this turn
    this.pebbles_played_this_turn=0;
    // reset the arrows placed count for this turn
    this.arrows_played_this_turn=0;

    if (this.hightlighted_pebble.Player!=null){
      highlight_pebble(this.hightlighted_pebble,false);
      this.hightlighted_pebble={Player:null,pebble:null};
    }

  }

  this.myturn = () => {
    //alert('my turn')
    // set to default all the pebble and arrow selection flags, so that there is no confusion later
    this.selected_arrow=null;
    this.selected_pbble=null;
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;
    this.arrow_starting_point=[null,null];
    this.arrow_ending_point=[null,null];
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];

    // pebbles and arrows played this turn;
    this.pebbles_played_this_turn=0;
    this.arrows_played_this_turn=0;
    //alert("the ending point is ["+this.arrow_ending_point[0]+","+this.arrow_ending_point[1]+"]");
    // remove main area addEventListener
    // remove panel addEventListener


    // first disable the other person's button;
    document.getElementById("finished"+this.opponentnumber).style.background=color_choice(this.opponentnumber,true);
    // then enable my button;
    document.getElementById("finished"+this.playernumber).style.background=color_choice(this.playernumber,false);
    // create eventlisteners
    if (this.playernumber==1){
      //alert('add event listeners')
      l_arr_cnv.addEventListener('click', self.select_arrow );
      l_peb_cnv.addEventListener('click', self.select_pebble);
      //alert('event listeners for canvases of '+this.playernumber+'are added')
    }  else  {
      r_arr_cnv.addEventListener('click', self.select_arrow );
      r_peb_cnv.addEventListener('click', self.select_pebble);
      //alert('event listeners for canvases of '+this.playernumber+'are added')
    }
  }

  this.select_arrow = (evt) => {
    //alert('arrow selection')
    //alert(this.selected_arrow==null && this.selected_pbble==null)
    //alert("the ending point is ["+this.arrow_ending_point[0]+","+this.arrow_ending_point[1]+"]");
    //alert('arrow selected (null or not) ' +this.selected_arrow)
    var rect = this.arrowsarea.canvas.getBoundingClientRect();
    var posx = evt.clientX - rect.left;
    var posy = evt.clientY - rect.top;
    var arr_in;

    // conditions for placement contraints. Are we allowed to select
    var selection_condition_1=!ThisGame.constrain_placements_per_turn;
    var selection_condition_2=ThisGame.constrain_placements_per_turn && this.arrows_played_this_turn<ThisGame.per_turn_moves.max_arrow && (this.arrows_played_this_turn+this.pebbles_played_this_turn)<ThisGame.per_turn_moves.max_pebble_and_arrow;
    var selection_condition_3=ThisGame.place_arrow_only_on_pebbles && MainArea.pebbles_nr<2;
    var selection_condition = !selection_condition_3 && (selection_condition_1 || selection_condition_2);
    // if any of these conditions holds, then we can go ahead and select.
    if (selection_condition){
      if (this.selected_arrow==null && this.selected_pbble==null){
        //alert(this.arrows_instock.length)
        for (arr_in=0; arr_in<this.arrows; arr_in++ ) {
          //alert(arr_in);
          if (this.arrows_instock[arr_in]!=null){
            //alert("the distance of "+arr_in+" is "+
            //Math.abs(posy-this.arrows_instock[arr_in].fromy)+
            //". It is smaller than half the grid_dy: "+this.arrowsarea.grid_dy/2+
            //". Then say so "+(Math.abs(posy-this.arrows_instock[arr_in].fromy)<this.arrowsarea.grid_dy/2));
            if (Math.abs(posy-this.arrows_instock[arr_in].fromy)<this.arrowsarea.grid_dy/2){
              // so arr_in is the one.
              //alert(""+arr_in+" is the lucky one.");
              this.arrows_instock[arr_in].color='#ddd';
              this.arrows_instock[arr_in].update();
              this.selected_arrow=arr_in;

              marea_cnv.addEventListener('click',  self.place_arrow);
              //marea_cnv.addEventListener('click', (evt) => {this.place_arrow(evt)} );

            }
          }

        }
      } else {
        // pebble could also be selected at the same time. If not then an arrow
        // had been selected previously and we should undo the selection Random
        // remove the event listener to the main area again.
        if (this.selected_pbble==null){
          this.arrows_instock[this.selected_arrow].color=this.color;
          this.arrows_instock[this.selected_arrow].update();
          this.selected_arrow=null;

          // removeEventListener of the main area
          marea_cnv.removeEventListener('click', self.place_arrow );
        }
        // if a pebble is selected then nothing will happen.
      }
    }

    //alert("the ending point is ["+this.arrow_ending_point[0]+","+this.arrow_ending_point[1]+"]");

  }

  this.find_event_point = (canvasarea,evt) =>{
    var found_flag;
    var location=[,];
    var rect = canvasarea.canvas.getBoundingClientRect();
    var posx = evt.clientX - rect.left;
    var posy = evt.clientY - rect.top;
    var x_grip_pos,x_cond,y_grip_pos,y_cond;
    var x_in, y_in;
    for (x_in=0; x_in<canvasarea.xpts; x_in++){
      x_grip_pos= canvasarea.padding+x_in*canvasarea.grid_dx;
      x_cond = Math.abs(posx-x_grip_pos)<canvasarea.grid_dx/2;
      for (y_in=0; y_in<canvasarea.ypts; y_in++){
        y_grip_pos= canvasarea.padding+y_in*canvasarea.grid_dy;
        y_cond = Math.abs(posy-y_grip_pos)<canvasarea.grid_dy/2;
        if (x_cond && y_cond){
          //this is the starting point
          location=[x_in,y_in];
          found_flag=true;
        }
      }
    }
    return {found_flag: found_flag, location: location};
  }

  this.place_arrow = (evt) => {
    // check if starting point has been found already
    if (!this.found_arrow_starting){
      var startingloc = this.find_event_point(MainArea,evt);
      //this.cannot_place_two_pebbles_on_same_site=true;
      var are_pebbles_here=MainArea.are_pebbles_here(startingloc.location);
      // if there are pebbles, i.e. pebbleshere.length>0
      // then select the last pebble that was placed there and highlight it.
      var how_many_pebbs=are_pebbles_here.length;
      var condition_1=ThisGame.place_arrow_only_on_pebbles && how_many_pebbs>0;
      var condition_2=!ThisGame.place_arrow_only_on_pebbles
      //alert(""+condition_1+condition_2)
      //var found_starting=this.cannot_place_two_pebbles_on_same_site;
      if (condition_1 || condition_2){
        this.arrow_starting_point=startingloc.location;
        this.found_arrow_starting=startingloc.found_flag;
        // highlight last pebble but stop the highlighting when either
        // 1) the arrow is placed. 2) the player presses finished. 3) the reset button is pressed
        if (how_many_pebbs>0){
          var last_placed_pebble=are_pebbles_here[how_many_pebbs-1];
          // enable the highlighted pebble flag
          this.hightlighted_pebble={
            Player:last_placed_pebble.Player_nr,
            pebble:last_placed_pebble.pebble_number};
          // actually highlight that pebble
          highlight_pebble(this.hightlighted_pebble,true);

        }
      }

    } else {

      var endingloc = this.find_event_point(MainArea,evt);
      //selfedges not allowed.

        //"Its the same point"
        // nothing happens.
        //alert('its the same point')

        //alert('its not the same point')
        var are_pebbles_here=MainArea.are_pebbles_here(endingloc.location);
        //alert(are_pebbles_here.length)
        var are_arrows_here=MainArea.are_arrows_here(this.arrow_starting_point,endingloc.location)
        //alert(are_arrows_here.length)
        var how_many_pebbs=are_pebbles_here.length;
        var how_many_arrws=are_arrows_here.length;
        //alert(""+ThisGame.place_arrow_only_on_pebbles+(how_many_pebbs>0));
        var condition_1=ThisGame.place_arrow_only_on_pebbles && how_many_pebbs>0;
        var condition_2=!ThisGame.place_arrow_only_on_pebbles;
        var arrow_on_pebble=condition_1||condition_2;

        // arrows not ontop of each other, if yes, than make second arrow thinner, but not vanish.
        var condition_3= ThisGame.place_arrows_atop ;
        var condition_4=!ThisGame.place_arrows_atop && how_many_arrws==0;
        var arrows_atop=condition_3 || condition_4;
        // Euclidean distance
        var condition_5= ThisGame.constrain_arrow_dist_to==null;
        var condition_6=!condition_5 && Euclidean(this.arrow_starting_point,endingloc.location)<=ThisGame.constrain_arrow_dist_to;
        var EuclideanDist=condition_5 || condition_6;

        var condition_7=ThisGame.allow_self_arrow;
        var condition_8=!ThisGame.allow_self_arrow && !(endingloc.location[0]==this.arrow_starting_point[0] && endingloc.location[1]==this.arrow_starting_point[1]);
        var self_arrow=condition_7 || condition_8;

        if (arrow_on_pebble && arrows_atop && EuclideanDist && self_arrow) {
          highlight_pebble(this.hightlighted_pebble,false);
          this.hightlighted_pebble={Player:null,pebble:null};
          this.arrow_ending_point=endingloc.location;
          this.found_arrow_ending=endingloc.found_flag;
          if (how_many_arrws>0){
            //make the next arrow slightly smaller
          }
        }



    }

    if (this.found_arrow_starting && this.found_arrow_ending){
      // add arrow to the main GameArea
      var placed_arrow = new canvas_arrow(MainArea,this.arrow_starting_point, this.arrow_ending_point,this.color,this.arrowwidth,this.selected_arrow);
      placed_arrow.apropriate(this.playernumber); // give it an owner id
      MainArea.arrow_nr+=1; // increment the arrow number of the main board
      placed_arrow.set_placement_number(MainArea.arrow_nr);
      var placed_element= {Player_nr:this.playernumber, arrow_number:this.selected_arrow, placement_number:MainArea.arrow_nr, placement_starting_pos: this.arrow_starting_point,  placement_ending_pos: this.arrow_ending_point };
      MainArea.arrow_placements.push(placed_element);
      //alert(MainArea.arrow_placements.length);
      // add this arrow to the infield stock and show it there
      this.arrows_infield[this.selected_arrow]=placed_arrow;
      //this.arrows_infield[this.selected_arrow].update(); //probably wont need this later
      MainArea.refresh();
      //alert('infield arrow')
      // delete the selected arrow from the stock
      this.arrows_instock[this.selected_arrow]=null;
      this.selected_arrow==null;
      this.update_arrow_canvas(); // update the arrow canvas;

      this.reset_flags(); // reset the all flags and initializations of vector points and pebble positions.
      this.arrows_played_this_turn+=1;
      // removeEventListener of the main area
      marea_cnv.removeEventListener('click', self.place_arrow );
      // also remove the listeners to the canvases (might change this for other games)
    }
  }

  this.place_pebble =(evt)=>{
    //alert('place pebble')
    var findloc = this.find_event_point(MainArea,evt);

    var are_pebbles_here=MainArea.are_pebbles_here(findloc.location);

    var condition_1=!ThisGame.place_pebbles_atop && are_pebbles_here.length==0;
    var condition_2=ThisGame.place_pebbles_atop;
    //ThisGame.place_pebbles_atop;
    //this.place_arrows_atop=false;
    if (condition_1 || condition_2){
      this.pebble_position=findloc.location;
      this.found_pebble_position=findloc.found_flag;
    }

    if (this.found_pebble_position){
      var placed_pebble = new canvas_pebbles(MainArea, this.pebble_position, this.color,this.pebblesize, this.selected_pbble);
      placed_pebble.apropriate(this.playernumber);
      MainArea.pebbles_nr+=1;
      placed_pebble.set_placement_number(MainArea.pebbles_nr);
      var placed_element= {Player_nr:this.playernumber, pebble_number:this.selected_pbble, placement_number:MainArea.pebbles_nr, placement_pos:this.pebble_position};
      MainArea.pebble_placements.push(placed_element);
      // add this pebble to the infield stock and show it there
      this.pebbls_infield[this.selected_pbble]=placed_pebble;
      //this.pebbls_infield[this.selected_pbble].update();
      //alert('update my field')
      MainArea.refresh();
      // delete the selected arrow from the stock
      this.pebbls_instock[this.selected_pbble]=null;
      this.selected_pbble==null;
      //alert('update pebbles canvas')
      this.update_pebbles_canvas(); // update the arrow canvas;

      this.reset_flags(); // reset the all flags and initializations of vector points and pebble positions.

      this.pebbles_played_this_turn+=1; // but pebbles played increases.

      // removeEventListener of the main area
      marea_cnv.removeEventListener('click', self.place_pebble );
    }

  }

  this.select_pebble = (evt) => {
    //alert('select pebble')
    var rect = this.pebblsarea.canvas.getBoundingClientRect();
    var posx = evt.clientX - rect.left;
    var posy = evt.clientY - rect.top;
    var pbl_in;
    //alert(Math.abs(this.arrows))
    //per_turn_moves={
    //  max_arrow:1,
    //  max_pebble:1,
    //  max_pebble_and_arrow:1}
    //alert(ThisGame)
    //alert(!ThisGame.constrain_placements_per_turn)
    var selection_condition_1=!ThisGame.constrain_placements_per_turn;
    var selection_condition_2=ThisGame.constrain_placements_per_turn && (this.pebbles_played_this_turn<ThisGame.per_turn_moves.max_pebble && (this.arrows_played_this_turn+this.pebbles_played_this_turn)<ThisGame.per_turn_moves.max_pebble_and_arrow);
    //alert(selection_condition_1)
    //  alert(selection_condition_2)
    if (selection_condition_1 || selection_condition_2){
    //if (this.pebbles_played_this_turn<ThisGame.per_turn_moves.max_pebble && (this.arrows_played_this_turn+this.pebbles_played_this_turn)<ThisGame.per_turn_moves.max_pebble_and_arrow){
      // only then I may select
      if (this.selected_pbble==null && this.selected_arrow==null){

        for (pbl_in=0; pbl_in<this.pebbles; pbl_in++ ) {
          if (this.pebbls_instock[pbl_in]!=null){
            //alert("the distance "+
            //Math.abs(posy-this.arrows_instock[arr_in].fromy)+
            //" is smaller than half the grid_dy: "+this.arrowsarea.grid_dy/2+
            //". Then say so "+(Math.abs(posy-this.arrows_instock[arr_in].fromy)<this.arrowsarea.grid_dy/2));
            let y_cond = Math.abs(posy-this.pebbls_instock[pbl_in].y)<this.pebblsarea.grid_dy/2;
            let x_cond = Math.abs(posx-this.pebbls_instock[pbl_in].x)<this.pebblsarea.grid_dx/2;
            if (x_cond && y_cond){
              // so arr_in is the one.
              //alert(""+arr_in);
              this.pebbls_instock[pbl_in].color='#ddd';
              this.pebbls_instock[pbl_in].update();
              this.selected_pbble=pbl_in;

              marea_cnv.addEventListener('click',  self.place_pebble);
            }
          }

        }
      } else {
        // either pebble or arrow is already selected
        if (this.selected_arrow==null){
          // pebble is already selected. So place it back
          this.pebbls_instock[this.selected_pbble].color=this.color;
          this.pebbls_instock[this.selected_pbble].update();
          this.selected_pbble=null;

          marea_cnv.removeEventListener('click',  self.place_pebble);
        }
      }

    }
  }


  this.reset_flags = ()=>{
    this.selected_arrow=null;
    this.selected_pbble=null;
    // reset the arrow beginning and starting finding flags
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;
    // reset the arrow beginning and ending points to null
    this.arrow_beginning_point=[null,null];
    this.arrow_ending_point=[null,null];
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];

    this.hightlighted_pebble={Player:null,pebble:null};

  }
}




//function trythisbitch(evt) {Player1.place_arrow(evt)}

function canvas_arrow(gamearea, from, to, color, arrow_width, id) {
  //alert(""+gamearea.padding)
  this.id=id;

  this.fromxi=from[0];
  this.fromyi=from[1];
  this.toxi=to[0];
  this.toyi=to[1];
  this.fromx=gamearea.padding+this.fromxi*(gamearea.width-2*gamearea.padding)/(gamearea.xpts-1);
  if (gamearea.mainarea){
    this.fromy=gamearea.padding+this.fromyi*gamearea.grid_dy;
    this.toy=gamearea.padding+this.toyi*gamearea.grid_dy;
  } else {
    this.fromy=(this.fromyi+1/2)*gamearea.grid_dy;
    this.toy=(this.toyi+1/2)*gamearea.grid_dy;
  }

  this.tox=gamearea.padding+this.toxi*gamearea.grid_dx;
  this.linewidth=arrow_width;
  this.pebblesize_estimate=5;
  this.headlenth = 15; // length of head in pixels
  this.color=color;
  this.apropriate = function (owner) {
    this.owner = owner;
  }
  this.set_placement_number = function (nr) {
    this.placement_number=nr;
  }
  var dx = this.tox - this.fromx;
  var dy = this.toy - this.fromy;
  this.angle=Math.atan2(dy, dx);
  this.update = function() {
    let subtractpbbl = [this.pebblesize_estimate*Math.cos(this.angle),this.pebblesize_estimate*Math.sin(this.angle)];
    let subtracthead = [this.headlenth*Math.cos(Math.PI/6)*Math.cos(this.angle),this.headlenth*Math.cos(Math.PI/6)*Math.sin(this.angle)];
    let little_extra = [2*Math.cos(this.angle),2*Math.sin(this.angle)];
    gamearea.context.beginPath();
    gamearea.context.moveTo(this.tox - subtractpbbl[0], this.toy - subtractpbbl[1]);
    gamearea.context.lineTo(this.tox - subtractpbbl[0]- this.headlenth * Math.cos(this.angle - Math.PI / 6), this.toy - subtractpbbl[1] - this.headlenth * Math.sin(this.angle - Math.PI / 6));
    gamearea.context.lineTo(this.tox - subtractpbbl[0]- this.headlenth * Math.cos(this.angle + Math.PI / 6), this.toy - subtractpbbl[1] - this.headlenth * Math.sin(this.angle + Math.PI / 6));
    gamearea.context.lineTo(this.tox - subtractpbbl[0], this.toy - subtractpbbl[1]);
    gamearea.context.fillStyle=this.color;
    gamearea.context.fill();
    gamearea.context.lineWidth = 1;
    gamearea.context.strokeStyle = "black";
    gamearea.context.stroke();
    gamearea.context.beginPath();
    gamearea.context.lineWidth=this.linewidth;
    gamearea.context.moveTo(this.fromx + subtractpbbl[0]- little_extra[0], this.fromy + subtractpbbl[1] -little_extra[1] );
    gamearea.context.lineTo(this.tox-subtracthead[0]-subtractpbbl[0], this.toy-subtracthead[1]-subtractpbbl[1]);
    gamearea.context.strokeStyle='black';
    gamearea.context.stroke();
    gamearea.context.beginPath();
    gamearea.context.lineWidth=this.linewidth-2;
    gamearea.context.moveTo(this.fromx + subtractpbbl[0]-little_extra[0], this.fromy + subtractpbbl[1]-little_extra[1]);
    gamearea.context.lineTo(this.tox-subtracthead[0] - subtractpbbl[0] +little_extra[0], this.toy-subtracthead[1]-subtractpbbl[1] + little_extra[1]);
    gamearea.context.strokeStyle=this.color;
    gamearea.context.stroke();
  }
}

function canvas_pebbles(gamearea, where, color,size, id) {
  //alert(""+gamearea.padding)
  this.id=id;
  this.xi=where[0];
  this.yi=where[1];
  this.size=size;
  this.x=gamearea.padding+this.xi*(gamearea.width-2*gamearea.padding)/(gamearea.xpts-1);
  if (gamearea.mainarea){
    this.y=gamearea.padding+this.yi*gamearea.grid_dy;
  } else {
    this.y=(this.yi+1/2)*gamearea.grid_dy;
  }

  this.color=color;
  this.apropriate = function (owner) {
    this.owner = owner;
  }
  this.set_placement_number = function (nr) {
    this.placement_number=nr;
  }
  this.update = function() {
    //alert(''+this.y+' and '+gamearea.padding+gamearea.width+gamearea.xpts)
    gamearea.context.fillStyle = this.color;
    gamearea.context.beginPath();
    gamearea.context.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
    gamearea.context.fill();
    gamearea.context.lineWidth = 1;
    gamearea.context.strokeStyle = "black";
    gamearea.context.stroke();
  }


}

const marea_cnv = document.querySelector('#GameField');
const l_arr_cnv = document.querySelector('#leftarrowcanvas');
const r_arr_cnv = document.querySelector('#rightarrowcanvas');
const l_peb_cnv = document.querySelector('#leftpebblescanvas');
const r_peb_cnv = document.querySelector('#rightpebblescanvas');
const Ply_1_fin = document.querySelector('#finished1');
const Ply_2_fin = document.querySelector('#finished2');
const Rules = document.querySelector('#Rules');
const Reset = document.querySelector('#Reset');


</script>
</html>
