<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" href="stylesheet.css">
</head>
<body onload="startGame()">
<div class="header">
  <h1> Testing Ground for Network Games</h1>
</div>
<div class="panel" id="leftpanel">
 <h3 id="Ply_1_name"> Player I </h3>
  <p> Pebbles </p>
 <canvas class="sidecanvas" id="leftpebblescanvas"></canvas>
 <p> Arrows </p>
 <canvas class="sidecanvas" id="leftarrowcanvas"></canvas>
</div>
<div class="canvascontainer" id="container">
  <canvas id="GameField"></canvas>
</div>
<div class="actionpanel">
  <button id="finished1">Player 1 to start</button>
  <button id="finished2">Player 2 to start</button>
</div>
<div class="gamepanel">
  <button id="Reset" style="background-color: #ccc;">Reset</button>
  <button id="Rules" style="background-color: #ccc;">How To Play</button>
</div>
<div class="panel" id="rightpanel">
  <h3 id="Ply_2_name"> Player II </h3>
  <p> Pebbles </p>
    <canvas class="sidecanvas" id="rightpebblescanvas"></canvas>
 <p> Arrows </p>
    <canvas class="sidecanvas" id="rightarrowcanvas"></canvas>
</div>
</body>
<script >

var mainfieldsizes=[300,300];
var panelfieldsizes=[100,190];
var per_turn_moves={
  max_arrow:1,
  max_pebble:1,
  max_pebble_and_arrow:1}

function color_choice(player_number,opaque) {
  if (player_number==1){
    if (opaque){ return 'rgba(255,127,80,0.5)'; }
    else { return 'rgba(255,127,80,1.0)';  }  }
  else {
    if (opaque){ return "rgba(115,144,153,0.5)"; }
    else { return "rgba(115,144,153,1.0)"; }  }
}

function startGame() {
    // add eventlisteners for the reset and rules buttons
    Reset.addEventListener('click', ()=>{reset()});
    // make the border colours of the panels conform to the players color;
    document.getElementById("leftpanel").style.borderColor=color_choice(1,false);
    document.getElementById("rightpanel").style.borderColor=color_choice(2,false);
    // make the buttons colours of the respective players conform to the colour pallette
    Ply_2_fin.style.background=color_choice(2,false);
    Ply_1_fin.style.background=color_choice(1,false);

    // initialize the main game area;
    var maincanvas=document.getElementById("GameField");
    maincanvas.width=mainfieldsizes[0];
    maincanvas.height=mainfieldsizes[1];
    window.MainArea = new GameArea(maincanvas,10,true);
    MainArea.setgridparameters(7,7,2,"#000");
    MainArea.updategrid();

    // define the GameRules
    ThisGame = new GameRules();
    ThisGame.constrain_placements_per_turn=true;
    ThisGame.place_arrow_only_on_pebbles=false;
    ThisGame.per_turn_moves=per_turn_moves;
    ThisGame.place_pebbles_atop=false;
    ThisGame.place_arrows_atop=false;
    ThisGame.constrain_arrow_dist_to=3;
    ThisGame.allow_self_arrow=false;
    // end when last arrow is placed or when one player finishes the arrows
    this.end_when_last_arrow_placed=true;

    // add the rules button.
    Rules.addEventListener('click', ThisGame.RulesText);

    // define the two players, both of "class" Player
    // players own the pebbles and arrows as methods and properties.
    var initial_pebbles=13;
    var initial_arrows=7;
    Player1= new Player(1,initial_pebbles,initial_arrows);
    Player2= new Player(2,initial_pebbles,initial_arrows);
    Players=[Player1,Player2];
    // initialize them.
    Player1.initialize();
    Player2.initialize();

    // add event listeners to the resepective player buttons.
    Ply_2_fin.addEventListener('click', Player_2_starts);
    Ply_1_fin.addEventListener('click', Player_1_starts);

}


function Player_1_starts () {

  // make the other button color faint.
  Ply_2_fin.style.background=color_choice(2,true);
  Ply_1_fin.style.background=color_choice(1,false);
  // change the innerHTML to I finished my turn.
  var finished_sentence='I\'m done';
  Ply_2_fin.innerHTML=finished_sentence;
  Ply_1_fin.innerHTML=finished_sentence;
  // remove eventlistener and add the new ones.
  Ply_2_fin.removeEventListener('click', Player_2_starts);
  Ply_1_fin.removeEventListener('click', Player_1_starts);
  //add event listeners
  add_finished_button_listeners();
  // let the games begin
  Player1.myturn()

}

function Player_2_starts () {
  // make the other button color faint.
  Ply_1_fin.style.background=color_choice(1,true);
  Ply_2_fin.style.background=color_choice(2,false);
  // change the innerHTML to I finished my turn.
  var finished_sentence='I\'m done';
  Ply_1_fin.innerHTML=finished_sentence;
  Ply_2_fin.innerHTML=finished_sentence;
  // remove eventlistener and add the new ones.
  Ply_1_fin.removeEventListener('click', Player_1_starts);
  Ply_2_fin.removeEventListener('click', Player_2_starts);
  //add event listeners
  add_finished_button_listeners();
  // let the games begin
  Player2.myturn()
}

function remove_finished_button_listeners (){
  //add_finished_button_listeners();
  Ply_2_fin.removeEventListener('click',Player1.myturn);
  Ply_2_fin.removeEventListener('click',Player2.removelisteners);
  Ply_2_fin.removeEventListener('click',Player2.undoselection);
  Ply_1_fin.removeEventListener('click',Player2.myturn);
  Ply_1_fin.removeEventListener('click',Player1.removelisteners);
  Ply_1_fin.removeEventListener('click',Player1.undoselection);
}

function add_finished_button_listeners (){
  //add_finished_button_listeners();
  Ply_2_fin.addEventListener('click',Player1.myturn);
  Ply_2_fin.addEventListener('click',Player2.removelisteners);
  Ply_2_fin.addEventListener('click',Player2.undoselection);
  Ply_1_fin.addEventListener('click',Player2.myturn);
  Ply_1_fin.addEventListener('click',Player1.removelisteners);
  Ply_1_fin.addEventListener('click',Player1.undoselection);
}

function reset(){

  MainArea.clear(true);
  MainArea.pebble_placements=new Array();
  MainArea.arrow_placements=new Array();
  MainArea.arrow_nr=0; // how many arrows there are currently on the board
  MainArea.pebbles_nr=0;
  Ply_2_fin.style.background=color_choice(2,false);
  Ply_1_fin.style.background=color_choice(1,false);
  remove_finished_button_listeners();
  Ply_2_fin.innerHTML="Player 2 to start";
  Ply_1_fin.innerHTML="Player 1 to start";
  // reset all the pebbles and arrows or player one and two
  Player1.initialize();
  Player2.initialize();

  remove_canvas_listeners();
  // remove listeners of the points
  Ply_2_fin.removeEventListener('click', Player2.get_points);
  Ply_1_fin.removeEventListener('click', Player1.get_points);
  // add eventlistener for whom to start.
  Ply_2_fin.addEventListener('click', Player_2_starts);
  Ply_1_fin.addEventListener('click', Player_1_starts);

}

function remove_canvas_listeners(){
  marea_cnv.removeEventListener('click', Player1.place_arrow );
  marea_cnv.removeEventListener('click', Player1.place_pebble );
  marea_cnv.removeEventListener('click', Player2.place_arrow );
  marea_cnv.removeEventListener('click', Player2.place_pebble );
  l_arr_cnv.removeEventListener('click', Player1.select_arrow );
  l_peb_cnv.removeEventListener('click', Player1.select_pebble);
  r_arr_cnv.removeEventListener('click', Player2.select_arrow );
  r_peb_cnv.removeEventListener('click', Player2.select_pebble);

}

function enable_counting_buttons(){
  //alert('enable buttons')
  Ply_2_fin.style.background=color_choice(2,false);
  Ply_1_fin.style.background=color_choice(1,false);
  remove_finished_button_listeners();
  Ply_2_fin.innerHTML="Extinction Wave";
  Ply_1_fin.innerHTML="Extinction Wave";
  // reset all the pebbles and arrows or player one and two
  remove_canvas_listeners();
  // add eventlistener for whom to start.
  Ply_2_fin.addEventListener('click', Extinctions);
  Ply_1_fin.addEventListener('click', Extinctions);
  //alert('buttons added ')
}

function Extinctions(){
  //alert('Lets evaluate')
  var total_number_of_pebbles=Player1.pebbles+Player2.pebbles;
  unfittest=MainArea.select_unfit();
  //alert(unfittest.which_weakest)
  //alert(unfittest.all_gone_flag)
  //all_gone_flag:flag,which_weakest
  if (unfittest.all_gone_flag){
    // deleting those will lead to deletion of all nodes.
    //alert(undo_ind)
    //alert('final move');
    var evaluation=MainArea.evaluation();
    //alert(evaluation)
    // the winner, or tier is bright-coloured
    Ply_2_fin.style.background=color_choice(2,!evaluation.winner[1]);
    Ply_1_fin.style.background=color_choice(1,!evaluation.winner[0]);
    //points,winner
    if (evaluation.winner[0] && evaluation.winner[1]){
      Ply_2_fin.innerHTML="It\'s a tie!";
      Ply_1_fin.innerHTML="It\'s a tie!";
    } else {
      if (evaluation.winner[0]) {
        Ply_1_fin.innerHTML="WINNER";
        Ply_2_fin.innerHTML="LOSER";
      } else {
        Ply_2_fin.innerHTML="WINNER";
        Ply_1_fin.innerHTML="LOSER";
      }
    }

    // remove eventlistener extinctions.
    Ply_2_fin.removeEventListener('click', Extinctions);
    Ply_1_fin.removeEventListener('click', Extinctions);

    // add eventlistener for whom to start.
    Ply_2_fin.addEventListener('click', Player2.get_points);
    Ply_1_fin.addEventListener('click', Player1.get_points);

  }
  else {
    // delete the weakest nodes and the arrows along with it.
    //setTimeout(function(){MainArea.delete_pebbles(unfittest.weakest) }, 500);
    //alert(unfittest.which_weakest)
    //alert(MainArea.pebble_placements.length)
    //alert('remove unfittest')

    MainArea.delete_pebbles(unfittest.which_weakest);
    //alert("there are this many pebbles left: ")
    //alert(MainArea.pebble_placements.length);
    MainArea.delete_arrows_without_source_or_sink();
    //alert(MainArea.pebble_placements.length)
  }
}

function GameArea (canvas,padding,mainarea){
  this.mainarea=mainarea;
  this.canvas=canvas;
  this.padding=padding;
  this.arrow_nr=0; // how many arrows there are currently on the board
  this.pebbles_nr=0; //how many pebbles there are currently on the board.
  // add this arrow to the infield stock and show it there
  this.pebble_placements=new Array();
  this.arrow_placements=new Array();
  this.width=this.canvas.width;
  this.height=this.canvas.height;
  this.context = this.canvas.getContext("2d");
  this.withgrid=false; // is there a grid or not;

  this.adjacency=[]; // empty adjacency matrix;
  this.clear = function(withgrid) {  // should become this.widthgrid.
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (withgrid){this.updategrid();}
    };
  this.setgridparameters = function(xpts,ypts,size,color) {
      this.xpts=xpts; // creates these properties of GameArea
      this.ypts=ypts;
      this.size=size;
      this.gridcolor=color;
      // defining the distance between 2 consecutive gridlines
      if (this.mainarea){
        this.grid_dy=(this.height-2*this.padding)/(this.ypts-1); // distance between two gridlines
      } else {
        this.grid_dy=this.height/(this.ypts);;
      };
      this.grid_dx=(this.width-2*this.padding)/(this.xpts-1);
    }
  this.updategrid = function(){
      this.context.fillStyle = "red";
      this.withgrid=true;
      var ix,iy;
      for (iy=0; iy < this.ypts; iy++) {
        if (this.mainarea){
          var y= this.padding+iy*this.grid_dy;
        } else {
          var y=(iy+1/2)*this.grid_dy;
        }
        this.context.beginPath();
        this.context.moveTo(this.padding, y);
        this.context.lineTo(this.width-this.padding, y);
        this.context.strokeStyle = 'rgba(0,0,0,0.5)';
        this.context.lineWidth=1;
        this.context.stroke();
      }
      for (ix = 0; ix < this.xpts; ix++) {
        let x= this.padding+ix*this.grid_dx;
        this.context.beginPath();
        this.context.moveTo(x, this.padding);
        this.context.lineTo(x, this.height-this.padding);
        this.context.strokeStyle = 'rgba(0,0,0,0.5)';
        this.context.lineWidth=1;
        this.context.stroke();
        for (iy=0; iy < this.ypts; iy++) {
          if (this.mainarea){
            var y= this.padding+iy*this.grid_dy;
          } else {
            var y=(iy+1/2)*this.grid_dy;
          }
          this.context.fillStyle = this.gridcolor;
          this.context.beginPath();
          this.context.arc(x, y, this.size, 0, 2 * Math.PI);
          this.context.fill();
        }
      }
    }
    //var placed_element= {Player_nr:this.playernumber, arrow_number:this.selected_arrow, placement_number:MainArea.arrow_nr, placement_starting_pos: this.arrow_starting_point,  placement_ending_pos: this.arrow_ending_point };

    this.are_pebbles_here = function(pos) {
      //alert("look for pebbles at this position")
      var peb_ord_in; // pebbles order index
      var placements_obj=new Array();
      // Go through all pebbles and return the object of that placement
      for (peb_ord_in=0; peb_ord_in<this.pebble_placements.length; peb_ord_in++) {
        //alert(this.pebble_placements[peb_ord_in].placement_pos[0])
        condition=this.pebble_placements[peb_ord_in].placement_pos[0]==pos[0] && this.pebble_placements[peb_ord_in].placement_pos[1]==pos[1];
        if (condition){
          placements_obj.push(this.pebble_placements[peb_ord_in]);
        }
      }
      return(placements_obj);
    }

    this.are_arrows_here= function (loc_ini, loc_fini){
      var arr_ord_in; // pebbles order index
      var placements_obj=new Array();
      // Go through all pebbles and return the object of that placement
      for (arr_ord_in=0; arr_ord_in<this.arrow_placements.length; arr_ord_in++) {
        //alert(this.pebble_placements[peb_ord_in].placement_pos[0])
        condition_fini=this.arrow_placements[arr_ord_in].placement_ending_pos[0]==loc_fini[0] &&  this.arrow_placements[arr_ord_in].placement_ending_pos[1]==loc_fini[1];
        condition_ini=this.arrow_placements[arr_ord_in].placement_starting_pos[0]==loc_ini[0] &&  this.arrow_placements[arr_ord_in].placement_starting_pos[1]==loc_ini[1];
        if (condition_ini && condition_fini){
          placements_obj.push(this.arrow_placements[arr_ord_in]);
        }
      }
      return(placements_obj);
    }

    this.last_arrow_placed= function(){
      // check whether all of the infield arrows are non-null;
      return this.arrow_placements.length>=Player1.arrows+Player2.arrows;
    }

    this.update_adjacency=function(){
      // adjacency[i,j]=0 when there is no arrow from j to i.
      var Vertices=this.pebble_placements.length;
      var peb_ord_in, peb_ord_in_2;
      var adjacency = new Array(Vertices);
      for (peb_ord_in=0; peb_ord_in<Vertices; peb_ord_in++) {
        var temp= new Array(Vertices);
        for (peb_ord_in_2=0; peb_ord_in_2<Vertices; peb_ord_in_2++){
          to=this.pebble_placements[peb_ord_in].placement_pos;
          from=this.pebble_placements[peb_ord_in_2].placement_pos;
          number_of_arrows=this.are_arrows_here(from,to).length;
          temp[peb_ord_in_2] = number_of_arrows;
        }
        adjacency[peb_ord_in]=temp;
      }
      this.adjacency=adjacency;
    }

    this.indegree=function(){
      this.update_adjacency();
      var Vertices=this.pebble_placements.length;
      var peb_ord_in;
      var indegree = new Array(Vertices);
      for (peb_ord_in=0; peb_ord_in<Vertices; peb_ord_in++) {
        indegree[peb_ord_in]=  this.adjacency[peb_ord_in].reduce((a, b) => a + b, 0);
      }
      return indegree;
    }

    this.select_unfit=function(){
      //alert('start searching the unfit')
      indegree=this.indegree();
      var indegree_copy= new Array(indegree.length);
      var indi;
      for (indi=0; indi<indegree.length; indi++){
        indegree_copy[indi]=indegree[indi];
      }
      //alert(indegree_copy);
      var Vertices=this.pebble_placements.length;
      indegree_copy.sort(); //sorts accending. // this weirdly changes indegree??

      //alert(indegree_copy)
      var unfittest=indegree_copy[0];
      //alert(unfittest)
      var weakest=[];
      var peb_in;
      // collect all unfittest and if its all vertices raise a flag;
      var flag=false;
      //alert(indegree)
      for (peb_in=0;peb_in<Vertices;peb_in++){
        //alert(indegree[peb_in])
        if (indegree[peb_in]==unfittest){

          weakest.push(peb_in);
          //alert(weakest);
        }
      }
      //alert(weakest)
      if (weakest.length==this.pebble_placements.length){
        flag=true;
      }
      var obj ={all_gone_flag:flag,which_weakest:weakest};
      return obj;
    }

    this.delete_pebbles = function(nodes){
      nodes.reverse(); // start splicing the largest indices first
      //alert(nodes);
      var NumberOfNodes=nodes.length;
      var temp_placements=this.pebble_placements;
      //alert(temp_placements.length)
      var nodes_ind;
      for (nodes_ind=0; nodes_ind<NumberOfNodes; nodes_ind++){
        //alert(nodes[nodes_ind])
        temp_placements.splice(nodes[nodes_ind],1);
        //alert(temp_placements.length)
      }
      //alert(temp_placements.length)
      this.pebble_placements=temp_placements;
      this.refresh();
    }

    this.delete_arrows_without_source_or_sink = function(){
      //alert('lets also delete the arrows')
      var arr_in;
      var temp_placements=this.arrow_placements;
      // he doesnt know pebbles_placements anymore
      //alert("this many pebbles left: "+this.pebble_placements.length)

      //alert("this many arrows left: "+temp_placements.length)
      for (arr_in=this.arrow_placements.length-1; arr_in>=0; arr_in--){
        var cond_1=this.are_pebbles_here(this.arrow_placements[arr_in].placement_starting_pos).length==0;
        var cond_2=this.are_pebbles_here(this.arrow_placements[arr_in].placement_ending_pos).length==0;

        if (cond_1 || cond_2){
          // either sink or source has no pebble
          temp_placements.splice(arr_in,1);
        }
      }
      this.arrow_placements=temp_placements;
      this.refresh();
    }

    this.evaluation = function (){
      var peb_in; // pebbles order index
      var points=[0,0];
      var winner=[false,false];
      for (peb_in=0; peb_in<this.pebble_placements.length; peb_in++) {
        points[this.pebble_placements[peb_in].Player_nr-1]=1+points[this.pebble_placements[peb_in].Player_nr-1];
      }
      winner[0]=points[0]>=points[1];
      winner[1]=points[1]>=points[0];
      // assign the points to the players
      Player1.points=points[0];
      Player2.points=points[1];
      var evaluation={points:points,winner:winner};
      return evaluation;

    }

    this.refresh = function(){
      // clear everything
      this.clear(this.withgrid);
      // first all the pebbles then all the arrows in their order of placement.
      var peb_ord_in, arr_ord_in; // pebbles order index
      // probably I should first find the order of pebbles this.pebble_placements.placement_number;
      for (peb_ord_in=0; peb_ord_in<this.pebble_placements.length; peb_ord_in++) {
        var element=this.pebble_placements[peb_ord_in];
        if (this.pebble_placements[peb_ord_in].Player_nr==1){
            Player1.pebbls_infield[element.pebble_number].update();}
        else{ Player2.pebbls_infield[element.pebble_number].update();}
      }
      for (arr_ord_in=0; arr_ord_in<this.arrow_placements.length; arr_ord_in++) {
        var element=this.arrow_placements[arr_ord_in];
        if (this.arrow_placements[arr_ord_in].Player_nr==1){
            Player1.arrows_infield[element.arrow_number].update();}
        else{ Player2.arrows_infield[element.arrow_number].update();}
      }
    }
}

function highlight_pebble(pebble_id_obj,highlight){

  if (pebble_id_obj.Player==1){
    var thepebble=Player1.pebbls_infield[pebble_id_obj.pebble];
  } else {
    var thepebble=Player2.pebbls_infield[pebble_id_obj.pebble];}

  thepebble.color=color_choice(pebble_id_obj.Player,highlight);
  if (highlight){thepebble.size+=2;} else {thepebble.size-=2;}
  MainArea.refresh();
}

function Player(playernumber, pebbles, arrows) {
  var self=this; //don't ask me why, but otherwise I cannot callback methods from Player. WTF. See https://stackoverflow.com/questions/20279484/how-to-access-the-correct-this-inside-a-callback
  this.playernumber=playernumber;
  this.opponentnumber=3-playernumber;
  this.color=color_choice(playernumber,false);
  this.pebbles=pebbles; //total number of pebbles in stock initially
  this.arrows=arrows; // total number of arrows in stock initially
  this.pebbles_played_this_turn=0;
  this.arrows_played_this_turn=0;
  this.hightlighted_pebble={Player:null,pebble:null};
  this.points=0;
  this.get_player_name = function(name){
    this.player_name=name;
    document.getElementById("Ply_"+this.playernumber+"_name").innerHTML=this.player_name;
  }
  //this.score= {"pebbles":init.pebbles, "arrows":init.arrows};
  if (this.playernumber==1){
    var arrowcanvas=l_arr_cnv;//document.getElementById("leftarrowcanvas");
    var pebblescanvas=l_peb_cnv;//document.getElementById("leftpebblescanvas");
  }  else  {
    var arrowcanvas=r_arr_cnv;//document.getElementById("rightarrowcanvas");
    var pebblescanvas=r_peb_cnv;//document.getElementById("rightpebblescanvas");
  }
  arrowcanvas.width=panelfieldsizes[0];
  arrowcanvas.height=panelfieldsizes[1];
  pebblescanvas.width=panelfieldsizes[0];
  pebblescanvas.height=panelfieldsizes[1];
  this.arrowsarea = new GameArea(arrowcanvas,10,false);
  this.pebblsarea = new GameArea(pebblescanvas,10,true);

  this.arrowwidth=5;
  this.arrowsarea.setgridparameters(2,arrows,2,"black");
  this.arrowsarea.updategrid();

  this.pebblesize=5;
  this.pebblecols=4;
  this.pebblsarea.setgridparameters(this.pebblecols,(pebbles-(pebbles%this.pebblecols))/this.pebblecols+1,2,"black");
  this.pebblsarea.updategrid();
  //alert('hello');
  //alert("width is "+this.arrowsarea.width+" and height is "+this.arrowsarea.height);
  //alert("width is and height is ");

  this.initialize = function() {
    //alert(this.arrowsarea.xpts);
    var arrows_instock = new Array(this.arrows);
    var pebbls_instock = new Array(this.pebbles);
    var arrows_infield = new Array(this.arrows);
    var pebbls_infield = new Array(this.pebbles);

    var arr_in,peb_in;

    // add the arrows to the stock
    for (arr_in=0; arr_in<this.arrows; arr_in++ ){
      arrows_instock[arr_in] = new canvas_arrow(this.arrowsarea, [0,arr_in], [1,arr_in],this.color,this.arrowwidth,arr_in);
      arrows_instock[arr_in].update();
    }
    this.arrows_instock=arrows_instock;

    // add the pebbles to the stock.
    for (peb_in=0; peb_in<this.pebbles; peb_in++) {
      let x_in=peb_in%this.pebblecols;
      let y_in=(peb_in-x_in)/this.pebblecols;
      pebbls_instock[peb_in] = new canvas_pebbles(this.pebblsarea, [x_in,y_in], this.color,this.pebblesize,peb_in);
      pebbls_instock[peb_in].update();
    }
    this.pebbls_instock=pebbls_instock;

    // add the arrow and pebbles to the field (initially none)
    this.arrows_infield=arrows_infield;
    this.pebbls_infield=pebbls_infield;

    this.selected_arrow=null;
    this.selected_pbble=null;
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;
    this.arrow_starting_point=[null,null];
    this.arrow_ending_point=[null,null];
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];
    // highlight pebble on marking.
    this.hightlighted_pebble={Player:null,pebble:null};

  }

  this.get_points= ()=>{
    alert("You have "+this.points+" surviving species.");
  }

  this.update_arrow_canvas = () => {
    // clear the arrow and pebbles canvases

    this.arrowsarea.clear(true);
    // initialize looping indices
    var arr_in;
    // update the arrows to the stock
    for (arr_in=0; arr_in<this.arrows; arr_in++ ){
      if (this.arrows_instock[arr_in] != null){this.arrows_instock[arr_in].update(); }
    }
  }

  this.update_pebbles_canvas = () => {
    //alert('update pebbles canvas inside function')
    // clear the arrow and pebbles canvases
    this.pebblsarea.clear(true);
    // initialize looping indices
    var peb_in;
    // add the pebbles to the stock.
    for (peb_in=0; peb_in<this.pebbles; peb_in++) {
      if (this.pebbls_instock[peb_in] != null){this.pebbls_instock[peb_in].update(); };
    }
  }

  this.update_canvases = () => {
    // update all the canvases from the player side.
    this.update_pebbles_canvas();
    this.update_arrow_canvas();
  }

  this.removelisteners = () => {
    if (this.playernumber==1){
      l_arr_cnv.removeEventListener('click', this.select_arrow );
      l_peb_cnv.removeEventListener('click', this.select_pebble);
      //alert('event listeners for player'+this.playernumber+' canvases are removed')
    }  else  {
      r_arr_cnv.removeEventListener('click', this.select_arrow );
      r_peb_cnv.removeEventListener('click', this.select_pebble);
      //alert('event listeners for player'+this.playernumber+' canvases are removed')

    }
  }

  this.undoselection = () => {
    if (this.selected_pbble!=null){
      this.pebbls_instock[self.selected_pbble].color=this.color;
      this.pebbls_instock[self.selected_pbble].update();
    }
    if (this.selected_arrow!=null){
      // arrow hasn't been placed.
      this.arrows_instock[self.selected_arrow].color=this.color;
      this.arrows_instock[self.selected_arrow].update();
    }
    // removeEventListener of the main area
    marea_cnv.removeEventListener('click', self.place_arrow );
    // removeEventListener of the main area
    marea_cnv.removeEventListener('click', self.place_pebble );
    this.selected_pbble=null;
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];
    this.selected_arrow=null;
    this.arrow_starting_point=[null,null];
    this.arrow_ending_point=[null,null];
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;

    // reset the pebbles placed count for this turn
    this.pebbles_played_this_turn=0;
    // reset the arrows placed count for this turn
    this.arrows_played_this_turn=0;

    if (this.hightlighted_pebble.Player!=null){
      highlight_pebble(this.hightlighted_pebble,false);
      this.hightlighted_pebble={Player:null,pebble:null};
    }

  }

  this.myturn = () => {
    //alert('my turn')
    // set to default all the pebble and arrow selection flags, so that there is no confusion later
    this.selected_arrow=null;
    this.selected_pbble=null;
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;
    this.arrow_starting_point=[null,null];
    this.arrow_ending_point=[null,null];
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];

    // pebbles and arrows played this turn;
    this.pebbles_played_this_turn=0;
    this.arrows_played_this_turn=0;
    //alert("the ending point is ["+this.arrow_ending_point[0]+","+this.arrow_ending_point[1]+"]");
    // remove main area addEventListener
    // remove panel addEventListener


    // first disable the other person's button;
    document.getElementById("finished"+this.opponentnumber).style.background=color_choice(this.opponentnumber,true);
    // then enable my button;
    document.getElementById("finished"+this.playernumber).style.background=color_choice(this.playernumber,false);
    // create eventlisteners
    if (this.playernumber==1){
      //alert('add event listeners')
      l_arr_cnv.addEventListener('click', self.select_arrow );
      l_peb_cnv.addEventListener('click', self.select_pebble);
      //alert('event listeners for canvases of '+this.playernumber+'are added')
    }  else  {
      r_arr_cnv.addEventListener('click', self.select_arrow );
      r_peb_cnv.addEventListener('click', self.select_pebble);
      //alert('event listeners for canvases of '+this.playernumber+'are added')
    }
  }

  this.select_arrow = (evt) => {
    //alert('arrow selection')
    //alert(this.selected_arrow==null && this.selected_pbble==null)
    //alert("the ending point is ["+this.arrow_ending_point[0]+","+this.arrow_ending_point[1]+"]");
    //alert('arrow selected (null or not) ' +this.selected_arrow)
    var rect = this.arrowsarea.canvas.getBoundingClientRect();
    var posx = evt.clientX - rect.left;
    var posy = evt.clientY - rect.top;
    var arr_in;

    // conditions for placement contraints. Are we allowed to select
    var selection_condition_1=!ThisGame.constrain_placements_per_turn;
    var selection_condition_2=ThisGame.constrain_placements_per_turn && this.arrows_played_this_turn<ThisGame.per_turn_moves.max_arrow && (this.arrows_played_this_turn+this.pebbles_played_this_turn)<ThisGame.per_turn_moves.max_pebble_and_arrow;
    var selection_condition_3=ThisGame.place_arrow_only_on_pebbles && MainArea.pebbles_nr<2;
    var selection_condition = !selection_condition_3 && (selection_condition_1 || selection_condition_2);
    // if any of these conditions holds, then we can go ahead and select.
    if (selection_condition){
      if (this.selected_arrow==null && this.selected_pbble==null){
        //alert(this.arrows_instock.length)
        for (arr_in=0; arr_in<this.arrows; arr_in++ ) {
          //alert(arr_in);
          if (this.arrows_instock[arr_in]!=null){
            //alert("the distance of "+arr_in+" is "+
            //Math.abs(posy-this.arrows_instock[arr_in].fromy)+
            //". It is smaller than half the grid_dy: "+this.arrowsarea.grid_dy/2+
            //". Then say so "+(Math.abs(posy-this.arrows_instock[arr_in].fromy)<this.arrowsarea.grid_dy/2));
            if (Math.abs(posy-this.arrows_instock[arr_in].fromy)<this.arrowsarea.grid_dy/2){
              // so arr_in is the one.
              //alert(""+arr_in+" is the lucky one.");
              this.arrows_instock[arr_in].color='#ddd';
              this.arrows_instock[arr_in].update();
              this.selected_arrow=arr_in;

              marea_cnv.addEventListener('click',  self.place_arrow);
              //marea_cnv.addEventListener('click', (evt) => {this.place_arrow(evt)} );

            }
          }

        }
      } else {
        // pebble could also be selected at the same time. If not then an arrow
        // had been selected previously and we should undo the selection Random
        // remove the event listener to the main area again.
        if (this.selected_pbble==null){
          this.arrows_instock[this.selected_arrow].color=this.color;
          this.arrows_instock[this.selected_arrow].update();
          this.selected_arrow=null;

          // removeEventListener of the main area
          marea_cnv.removeEventListener('click', self.place_arrow );
        }
        // if a pebble is selected then nothing will happen.
      }
    }

    //alert("the ending point is ["+this.arrow_ending_point[0]+","+this.arrow_ending_point[1]+"]");

  }

  this.find_event_point = (canvasarea,evt) =>{
    var found_flag;
    var location=[,];
    var rect = canvasarea.canvas.getBoundingClientRect();
    var posx = evt.clientX - rect.left;
    var posy = evt.clientY - rect.top;
    var x_grip_pos,x_cond,y_grip_pos,y_cond;
    var x_in, y_in;
    for (x_in=0; x_in<canvasarea.xpts; x_in++){
      x_grip_pos= canvasarea.padding+x_in*canvasarea.grid_dx;
      x_cond = Math.abs(posx-x_grip_pos)<canvasarea.grid_dx/2;
      for (y_in=0; y_in<canvasarea.ypts; y_in++){
        y_grip_pos= canvasarea.padding+y_in*canvasarea.grid_dy;
        y_cond = Math.abs(posy-y_grip_pos)<canvasarea.grid_dy/2;
        if (x_cond && y_cond){
          //this is the starting point
          location=[x_in,y_in];
          found_flag=true;
        }
      }
    }
    return {found_flag: found_flag, location: location};
  }

  this.place_arrow = (evt) => {
    // check if starting point has been found already
    if (!this.found_arrow_starting){
      var startingloc = this.find_event_point(MainArea,evt);
      //this.cannot_place_two_pebbles_on_same_site=true;
      var are_pebbles_here=MainArea.are_pebbles_here(startingloc.location);
      // if there are pebbles, i.e. pebbleshere.length>0
      // then select the last pebble that was placed there and highlight it.
      var how_many_pebbs=are_pebbles_here.length;
      var condition_1=ThisGame.place_arrow_only_on_pebbles && how_many_pebbs>0;
      var condition_2=!ThisGame.place_arrow_only_on_pebbles
      //alert(""+condition_1+condition_2)
      //var found_starting=this.cannot_place_two_pebbles_on_same_site;
      if (condition_1 || condition_2){
        this.arrow_starting_point=startingloc.location;
        this.found_arrow_starting=startingloc.found_flag;
        // highlight last pebble but stop the highlighting when either
        // 1) the arrow is placed. 2) the player presses finished. 3) the reset button is pressed
        if (how_many_pebbs>0){
          var last_placed_pebble=are_pebbles_here[how_many_pebbs-1];
          // enable the highlighted pebble flag
          this.hightlighted_pebble={
            Player:last_placed_pebble.Player_nr,
            pebble:last_placed_pebble.pebble_number};
          // actually highlight that pebble
          highlight_pebble(this.hightlighted_pebble,true);

        }
      }

    } else {

      var endingloc = this.find_event_point(MainArea,evt);
      //selfedges not allowed.

        //"Its the same point"
        // nothing happens.
        //alert('its the same point')

        //alert('its not the same point')
        var are_pebbles_here=MainArea.are_pebbles_here(endingloc.location);
        //alert(are_pebbles_here.length)
        var are_arrows_here=MainArea.are_arrows_here(this.arrow_starting_point,endingloc.location)
        //alert(are_arrows_here.length)
        var how_many_pebbs=are_pebbles_here.length;
        var how_many_arrws=are_arrows_here.length;
        //alert(""+ThisGame.place_arrow_only_on_pebbles+(how_many_pebbs>0));
        var condition_1=ThisGame.place_arrow_only_on_pebbles && how_many_pebbs>0;
        var condition_2=!ThisGame.place_arrow_only_on_pebbles;
        var arrow_on_pebble=condition_1||condition_2;

        // arrows not ontop of each other, if yes, than make second arrow thinner, but not vanish.
        var condition_3= ThisGame.place_arrows_atop ;
        var condition_4=!ThisGame.place_arrows_atop && how_many_arrws==0;
        var arrows_atop=condition_3 || condition_4;
        // Euclidean distance
        var condition_5= ThisGame.constrain_arrow_dist_to==null;
        var condition_6=!condition_5 && Euclidean(this.arrow_starting_point,endingloc.location)<=ThisGame.constrain_arrow_dist_to;
        var EuclideanDist=condition_5 || condition_6;

        var condition_7=ThisGame.allow_self_arrow;
        var condition_8=!ThisGame.allow_self_arrow && !(endingloc.location[0]==this.arrow_starting_point[0] && endingloc.location[1]==this.arrow_starting_point[1]);
        var self_arrow=condition_7 || condition_8;

        if (arrow_on_pebble && arrows_atop && EuclideanDist && self_arrow) {
          highlight_pebble(this.hightlighted_pebble,false);
          this.hightlighted_pebble={Player:null,pebble:null};
          this.arrow_ending_point=endingloc.location;
          this.found_arrow_ending=endingloc.found_flag;
          if (how_many_arrws>0){
            //make the next arrow slightly smaller
          }
          //when last arrow is placed then start the countdown;
        }



    }

    if (this.found_arrow_starting && this.found_arrow_ending){
      // add arrow to the main GameArea
      var placed_arrow = new canvas_arrow(MainArea,this.arrow_starting_point, this.arrow_ending_point,this.color,this.arrowwidth,this.selected_arrow);
      placed_arrow.apropriate(this.playernumber); // give it an owner id
      MainArea.arrow_nr+=1; // increment the arrow number of the main board
      placed_arrow.set_placement_number(MainArea.arrow_nr);
      var placed_element= {Player_nr:this.playernumber, arrow_number:this.selected_arrow, placement_number:MainArea.arrow_nr, placement_starting_pos: this.arrow_starting_point,  placement_ending_pos: this.arrow_ending_point };
      MainArea.arrow_placements.push(placed_element);
      //alert(MainArea.arrow_placements.length);
      // add this arrow to the infield stock and show it there
      this.arrows_infield[this.selected_arrow]=placed_arrow;
      //this.arrows_infield[this.selected_arrow].update(); //probably wont need this later
      MainArea.refresh();
      //alert('infield arrow')
      // delete the selected arrow from the stock
      this.arrows_instock[this.selected_arrow]=null;
      this.selected_arrow==null;
      this.update_arrow_canvas(); // update the arrow canvas;

      this.reset_flags(); // reset the all flags and initializations of vector points and pebble positions.
      this.arrows_played_this_turn+=1;
      // removeEventListener of the main area
      marea_cnv.removeEventListener('click', self.place_arrow );
      // also remove the listeners to the canvases (might change this for other games)

      if (MainArea.last_arrow_placed() && ThisGame.end_when_last_arrow_placed){
          // change the function of the two buttons;
          // do the counting.
          enable_counting_buttons()
      }
    }
  }

  this.place_pebble =(evt)=>{
    //alert('place pebble')
    var findloc = this.find_event_point(MainArea,evt);

    var are_pebbles_here=MainArea.are_pebbles_here(findloc.location);

    var condition_1=!ThisGame.place_pebbles_atop && are_pebbles_here.length==0;
    var condition_2=ThisGame.place_pebbles_atop;
    //ThisGame.place_pebbles_atop;
    //this.place_arrows_atop=false;
    if (condition_1 || condition_2){
      this.pebble_position=findloc.location;
      this.found_pebble_position=findloc.found_flag;
    }

    if (this.found_pebble_position){
      var placed_pebble = new canvas_pebbles(MainArea, this.pebble_position, this.color,this.pebblesize, this.selected_pbble);
      placed_pebble.apropriate(this.playernumber);
      MainArea.pebbles_nr+=1;
      placed_pebble.set_placement_number(MainArea.pebbles_nr);
      var placed_element= {Player_nr:this.playernumber, pebble_number:this.selected_pbble, placement_number:MainArea.pebbles_nr, placement_pos:this.pebble_position};
      MainArea.pebble_placements.push(placed_element);
      // add this pebble to the infield stock and show it there
      this.pebbls_infield[this.selected_pbble]=placed_pebble;
      //this.pebbls_infield[this.selected_pbble].update();
      //alert('update my field')
      MainArea.refresh();
      // delete the selected arrow from the stock
      this.pebbls_instock[this.selected_pbble]=null;
      this.selected_pbble==null;
      //alert('update pebbles canvas')
      this.update_pebbles_canvas(); // update the arrow canvas;

      this.reset_flags(); // reset the all flags and initializations of vector points and pebble positions.

      this.pebbles_played_this_turn+=1; // but pebbles played increases.

      // removeEventListener of the main area
      marea_cnv.removeEventListener('click', self.place_pebble );
    }

  }

  this.select_pebble = (evt) => {
    //alert('select pebble')
    var rect = this.pebblsarea.canvas.getBoundingClientRect();
    var posx = evt.clientX - rect.left;
    var posy = evt.clientY - rect.top;
    var pbl_in;
    //alert(Math.abs(this.arrows))
    //per_turn_moves={
    //  max_arrow:1,
    //  max_pebble:1,
    //  max_pebble_and_arrow:1}
    //alert(ThisGame)
    //alert(!ThisGame.constrain_placements_per_turn)
    var selection_condition_1=!ThisGame.constrain_placements_per_turn;
    var selection_condition_2=ThisGame.constrain_placements_per_turn && (this.pebbles_played_this_turn<ThisGame.per_turn_moves.max_pebble && (this.arrows_played_this_turn+this.pebbles_played_this_turn)<ThisGame.per_turn_moves.max_pebble_and_arrow);
    //alert(selection_condition_1)
    //  alert(selection_condition_2)
    if (selection_condition_1 || selection_condition_2){
    //if (this.pebbles_played_this_turn<ThisGame.per_turn_moves.max_pebble && (this.arrows_played_this_turn+this.pebbles_played_this_turn)<ThisGame.per_turn_moves.max_pebble_and_arrow){
      // only then I may select
      if (this.selected_pbble==null && this.selected_arrow==null){

        for (pbl_in=0; pbl_in<this.pebbles; pbl_in++ ) {
          if (this.pebbls_instock[pbl_in]!=null){
            //alert("the distance "+
            //Math.abs(posy-this.arrows_instock[arr_in].fromy)+
            //" is smaller than half the grid_dy: "+this.arrowsarea.grid_dy/2+
            //". Then say so "+(Math.abs(posy-this.arrows_instock[arr_in].fromy)<this.arrowsarea.grid_dy/2));
            let y_cond = Math.abs(posy-this.pebbls_instock[pbl_in].y)<this.pebblsarea.grid_dy/2;
            let x_cond = Math.abs(posx-this.pebbls_instock[pbl_in].x)<this.pebblsarea.grid_dx/2;
            if (x_cond && y_cond){
              // so arr_in is the one.
              //alert(""+arr_in);
              this.pebbls_instock[pbl_in].color='#ddd';
              this.pebbls_instock[pbl_in].update();
              this.selected_pbble=pbl_in;

              marea_cnv.addEventListener('click',  self.place_pebble);
            }
          }

        }
      } else {
        // either pebble or arrow is already selected
        if (this.selected_arrow==null){
          // pebble is already selected. So place it back
          this.pebbls_instock[this.selected_pbble].color=this.color;
          this.pebbls_instock[this.selected_pbble].update();
          this.selected_pbble=null;

          marea_cnv.removeEventListener('click',  self.place_pebble);
        }
      }

    }
  }


  this.reset_flags = ()=>{
    this.selected_arrow=null;
    this.selected_pbble=null;
    // reset the arrow beginning and starting finding flags
    this.found_arrow_starting=false;
    this.found_arrow_ending=false;
    // reset the arrow beginning and ending points to null
    this.arrow_beginning_point=[null,null];
    this.arrow_ending_point=[null,null];
    // reset the pebble finding flags
    this.found_pebble_position=false;
    // reset the pebble position to null
    this.pebble_position=[null,null];

    this.hightlighted_pebble={Player:null,pebble:null};

  }
}

function canvas_arrow(gamearea, from, to, color, arrow_width, id) {
  //alert(""+gamearea.padding)
  this.id=id;

  this.fromxi=from[0];
  this.fromyi=from[1];
  this.toxi=to[0];
  this.toyi=to[1];
  this.fromx=gamearea.padding+this.fromxi*(gamearea.width-2*gamearea.padding)/(gamearea.xpts-1);
  if (gamearea.mainarea){
    this.fromy=gamearea.padding+this.fromyi*gamearea.grid_dy;
    this.toy=gamearea.padding+this.toyi*gamearea.grid_dy;
  } else {
    this.fromy=(this.fromyi+1/2)*gamearea.grid_dy;
    this.toy=(this.toyi+1/2)*gamearea.grid_dy;
  }

  this.tox=gamearea.padding+this.toxi*gamearea.grid_dx;
  this.linewidth=arrow_width;
  this.pebblesize_estimate=5;
  this.headlenth = 15; // length of head in pixels
  this.color=color;
  this.apropriate = function (owner) {
    this.owner = owner;
  }
  this.set_placement_number = function (nr) {
    this.placement_number=nr;
  }
  var dx = this.tox - this.fromx;
  var dy = this.toy - this.fromy;
  this.angle=Math.atan2(dy, dx);
  this.update = function() {
    let subtractpbbl = [this.pebblesize_estimate*Math.cos(this.angle),this.pebblesize_estimate*Math.sin(this.angle)];
    let subtracthead = [this.headlenth*Math.cos(Math.PI/6)*Math.cos(this.angle),this.headlenth*Math.cos(Math.PI/6)*Math.sin(this.angle)];
    let little_extra = [2*Math.cos(this.angle),2*Math.sin(this.angle)];
    gamearea.context.beginPath();
    gamearea.context.moveTo(this.tox - subtractpbbl[0], this.toy - subtractpbbl[1]);
    gamearea.context.lineTo(this.tox - subtractpbbl[0]- this.headlenth * Math.cos(this.angle - Math.PI / 6), this.toy - subtractpbbl[1] - this.headlenth * Math.sin(this.angle - Math.PI / 6));
    gamearea.context.lineTo(this.tox - subtractpbbl[0]- this.headlenth * Math.cos(this.angle + Math.PI / 6), this.toy - subtractpbbl[1] - this.headlenth * Math.sin(this.angle + Math.PI / 6));
    gamearea.context.lineTo(this.tox - subtractpbbl[0], this.toy - subtractpbbl[1]);
    gamearea.context.fillStyle=this.color;
    gamearea.context.fill();
    gamearea.context.lineWidth = 1;
    gamearea.context.strokeStyle = "black";
    gamearea.context.stroke();
    gamearea.context.beginPath();
    gamearea.context.lineWidth=this.linewidth;
    gamearea.context.moveTo(this.fromx + subtractpbbl[0]- little_extra[0], this.fromy + subtractpbbl[1] -little_extra[1] );
    gamearea.context.lineTo(this.tox-subtracthead[0]-subtractpbbl[0], this.toy-subtracthead[1]-subtractpbbl[1]);
    gamearea.context.strokeStyle='black';
    gamearea.context.stroke();
    gamearea.context.beginPath();
    gamearea.context.lineWidth=this.linewidth-2;
    gamearea.context.moveTo(this.fromx + subtractpbbl[0]-little_extra[0], this.fromy + subtractpbbl[1]-little_extra[1]);
    gamearea.context.lineTo(this.tox-subtracthead[0] - subtractpbbl[0] +little_extra[0], this.toy-subtracthead[1]-subtractpbbl[1] + little_extra[1]);
    gamearea.context.strokeStyle=this.color;
    gamearea.context.stroke();
  }
}

function canvas_pebbles(gamearea, where, color,size, id) {
  //alert(""+gamearea.padding)
  this.id=id;
  this.xi=where[0];
  this.yi=where[1];
  this.size=size;
  this.x=gamearea.padding+this.xi*(gamearea.width-2*gamearea.padding)/(gamearea.xpts-1);
  if (gamearea.mainarea){
    this.y=gamearea.padding+this.yi*gamearea.grid_dy;
  } else {
    this.y=(this.yi+1/2)*gamearea.grid_dy;
  }

  this.color=color;
  this.apropriate = function (owner) {
    this.owner = owner;
  }
  this.set_placement_number = function (nr) {
    this.placement_number=nr;
  }
  this.update = function() {
    //alert(''+this.y+' and '+gamearea.padding+gamearea.width+gamearea.xpts)
    gamearea.context.fillStyle = this.color;
    gamearea.context.beginPath();
    gamearea.context.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
    gamearea.context.fill();
    gamearea.context.lineWidth = 1;
    gamearea.context.strokeStyle = "black";
    gamearea.context.stroke();
  }


}

function GameRules() {
  this.constrain_placements_per_turn=true;
  this.place_arrow_only_on_pebbles=true;
  this.per_turn_moves=per_turn_moves;
  this.place_pebbles_atop=false;
  this.place_arrows_atop=false;
  this.constrain_arrow_dist_to=3;
  this.allow_self_arrow=false;
  // end when last arrow is placed or when one player finishes the arrows
  this.end_when_last_arrow_placed=true;
  this.RulesText= () =>{

    var placement_text,arrows_only_on_pebs_text,multi_peb,multi_arr,euclid,selfarrow,end_on_last_arrow;
    if (this.constrain_placements_per_turn){
      placement_text="Each player may only make "+this.per_turn_moves.max_pebble_and_arrow+
      " moves per turn. The player may lay at most "+this.per_turn_moves.max_pebble+
      " pebbles and at most "+this.per_turn_moves.max_arrow+" arrows per turn."
    } else {
      placement_text="Each player can make as many moves as desired."
    }
    if (this.place_arrow_only_on_pebbles){
      arrows_only_on_pebs_text="Arrows need to begin and end on pebbles.";
    } else {
      arrows_only_on_pebs_text="Arrows need not have pebbles at the beginnings or ends.";
    }
    if (this.place_pebbles_atop){
        multi_peb=" There can be any number of pebbles on one site.";
    } else{
      multi_peb=" There must only by one pebble per site."
    }
    if (this.place_arrows_atop){
      multi_arr=" There can be any amount of arrows between two pebbles."
    } else {
      multi_arr=" There must only be at most one arrow for each pair of pebbles."
    }
    if (this.constrain_arrow_dist_to==null){
      euclid=" Arrows may be arbitrarily long"
    } else {
      euclid=" Arrows may only have a length of at most "+this.constrain_arrow_dist_to+" units."
    }
    if (this.allow_self_arrow){
      selfarrow=" Arrows may also be placed from a pebble to itself.";
    } else {
      selfarrow=" Arrows may not be placed from a pebble to itself, i.e. self-edges are forbidden.";
    }
    if (this.end_when_last_arrow_placed) {
      end_on_last_arrow="The placement part of the game ends when there are no arrows left in both of the players stocks."
    } else {
      end_on_last_arrow="The placement part of the game never ends! MUHAHAHAH!! EVIL LAUGHTER!"
    }
    if (this.end_when_last_arrow_placed) {
      second_stage=" In the second stage a wave of extinctions diminishes the pebbles. During one extinction wave the pebbles with the least amount of incoming arrows are removed and all the arrows that point to it or depart from it are deleted, too. "+
      "Click on the button \"Extinction Wave\" to trigger an extinction wave. "+
      "No more extinction waves are possible, when all species have the same number of incoming links. "+
      "Then the number of surviving species per player are counted and the winner is determined. Click on the Winner button to see your score!"
    } else {
      second_stage="";
    }


    var how_to_navigate_text =
    "**HOW TO NAVIGATE**\n\n"+
    "START: Press \"Player 1 to start\" or \"Player 2 to start\"\n\n"+
    "SELECTION OF PEBBLES AND ARROWS: "+
    "Upon your turn you may click on any of "+
    "the pebbles or arrows in your stock. Once a selection is made the pebble or arrow is marked and can be placed in the main field. By clicking again on the stock area you can unselect the pebble or arrow and make a new choice.\n\n"+
    "PLACEMENT OF PEBBLES: Once selected, a pebble is placed by clicking simply on the game area, close to one of the grid points where it ought to be placed."+
    multi_peb+" Once the pebble is placed it appears on the game area and disappears from the stock. Pebbles cannot be unplaced, once they are on the board.\n\n"+
    "PLACEMENT OF ARROWS: An arrow is placed by clicking on the starting grid point, or close by, and then after that on the finishing grid point."+
    selfarrow+" "+multi_arr+" "+euclid+
    " Once the arrow is placed it appears on the game area and disappears from the stock. Arrows cannot be unplaced once they are on the board.\n\n"+
    "PLACEMENTS PER TURN: "+placement_text+"\n\n"+
    "RESET: Pressing the Reset-button will clear all the placed pebbles and arrows from the field and replenish the respective stocks.";
    var how_to_play_text=
    "**STAGES OF THE GAME**\n\n"+
    "The game begins with the stage of placing pebbles and arrows. "+
    end_on_last_arrow+second_stage+"\n\n"+
    "**AIM OF THE GAME**\n\n"+
    "The aim of the game is to have the highest number of remaining pebbles after the extinction waves.";


    this.how_to_play_text=how_to_play_text;
    this.how_to_navigate_text=how_to_navigate_text;

    text_obj={
      placement:placement_text,
      arrows_on_pebs:arrows_only_on_pebs_text,
      multi_peb:multi_peb,
      multi_arr:multi_arr,
      euclid:euclid,
      selfarrow:selfarrow,
      ending:end_on_last_arrow,
      second_stage:second_stage
    }
    this.text_particles=text_obj;

    alert(how_to_navigate_text)
    alert(how_to_play_text)
  }
}

function Euclidean(x,y){return Math.sqrt(Math.pow(x[0]-y[0],2)+Math.pow(x[1]-y[1],2))}

function LpDist(x,y,p){
    var alert_flag=false;
    var Lenx=x.length;
    var Leny=y.length;
    if (Lenx!=Leny){
      if (alert_flag){alert('vectors not the same length')}
      Len=Math.min(Lenx,Leny);
    }
    else {
      Len=Lenx;
    }
    var temp=0;
    var index;
    for (index=0; index<Len; index++){
      temp+=Math.abs(Math.pow((x[0]-y[0]),p));
    }
   return Math.pow(temp,1/p);
}

const marea_cnv = document.querySelector('#GameField');
const l_arr_cnv = document.querySelector('#leftarrowcanvas');
const r_arr_cnv = document.querySelector('#rightarrowcanvas');
const l_peb_cnv = document.querySelector('#leftpebblescanvas');
const r_peb_cnv = document.querySelector('#rightpebblescanvas');
const Ply_1_fin = document.querySelector('#finished1');
const Ply_2_fin = document.querySelector('#finished2');
const Rules = document.querySelector('#Rules');
const Reset = document.querySelector('#Reset');


</script>
</html>
